1.synchronized
用途:
    synchronized用來確保同一段代碼在同一時間只能被一個執行緒執行，這樣能避免在多執行續的環境中，對共享資源的操作法生競爭

優點:
    1.易用容易理解，只要在方法或程式碼區塊加上關鍵字，就能保證同一時間只能被一個執行緒執行
    2.自動解決Race Condition，在進入同步區域的時候會自動獲得鎖(lock)，來避免其他執行緒進入
    3.確保原子性
缺點:
    1.性能開銷:請求鎖以及等待狀態，在高併發的環境下，性能會明顯下降
    2.有可能會產生死鎖(deadlock)
    3.不夠靈活
結論:
    線程競爭不激烈的情況下，性能表現良好
---------------------------------------------------------------------------------------------------

2.Atomic
用途:
    在不使用鎖的情況下，保證對數據的操作是原子性且線程安全的(透過硬體支持的Compare and Swap)
優點:
    比起synchronized，不會造成阻塞，提高高併發的效能。它的操作不需要顯式的鎖定，能實現高校的原子性操作
缺點:
    僅適用於基本數據類型(int,long)，對於複雜對象則無法使用(集合)
結論:
    在使用基本數據的時候，可以用Atomic
---------------------------------------------------------------------------------------------------
3.ReentrantLock
用途:
    ReentrantLock是java.util.concurrent包中的一種鎖，比synchronized更靈活，並提供更多控制(鎖的公平性及可中斷的鎖等)
結論:
    在需要考量高併發的情況下，優先使用ReentrantLock


補充:: 原子性即是防止競態條件的一種方式